#!/bin/bash

# CSV to YAML Config Builder
# Converts rsync_sources.csv to rsync_config.yaml for easy config management

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Default file paths
CSV_FILE="rsync_sources.csv"
CONFIG_FILE="rsync_config.yaml"
SKIP_CONFIRM=false

# Function to print colored output
print_status() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Function to display usage
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Converts a CSV file with source/destination pairs into rsync_config.yaml"
    echo ""
    echo "Options:"
    echo "  -i, --input <file>    CSV input file (default: rsync_sources.csv)"
    echo "  -o, --output <file>   YAML output file (default: rsync_config.yaml)"
    echo "  -y, --yes             Skip confirmation prompt (auto-overwrite)"
    echo "  -h, --help            Show this help message"
    echo ""
    echo "CSV Format:"
    echo "  The CSV file must have a header row with 'source' and 'destination' columns"
    echo "  Example:"
    echo "    source,destination"
    echo "    /Volumes/SOURCE/data,/Volumes/BACKUP/data"
    echo "    /Volumes/LAB/experiment,/Volumes/ARCHIVE/experiment"
    echo ""
    echo "Notes:"
    echo "  - You can edit the CSV in Excel, Numbers, or any spreadsheet application"
    echo "  - Make sure to save as CSV format"
    echo "  - Empty rows and rows starting with # are ignored"
    echo "  - The script will validate all paths before generating the config"
    exit 1
}

# Function to validate CSV file exists and has correct format
validate_csv() {
    local csv_file=$1

    if [ ! -f "$csv_file" ]; then
        print_status $RED "ERROR: CSV file '$csv_file' not found!"
        print_status $YELLOW "Create a CSV file with 'source' and 'destination' columns"
        return 1
    fi

    # Check if file has header
    local header=$(head -n 1 "$csv_file")
    if [[ ! "$header" =~ source.*destination ]] && [[ ! "$header" =~ destination.*source ]]; then
        print_status $RED "ERROR: CSV file must have 'source' and 'destination' columns in the header"
        print_status $YELLOW "Current header: $header"
        return 1
    fi

    # Count non-empty, non-comment rows (excluding header)
    local row_count=$(tail -n +2 "$csv_file" | grep -v '^#' | grep -v '^[[:space:]]*$' | wc -l | tr -d ' ')

    if [ "$row_count" -eq 0 ]; then
        print_status $RED "ERROR: No transfer entries found in CSV file"
        print_status $YELLOW "Add at least one row with source and destination paths"
        return 1
    fi

    print_status $GREEN "✓ CSV file validated: $row_count transfer(s) found"
    return 0
}

# Function to parse CSV and generate YAML
generate_yaml() {
    local csv_file=$1
    local output_file=$2

    print_status $BLUE "Generating YAML configuration..."

    # Start YAML file
    cat > "$output_file" << 'EOF'
# Auto-generated configuration from CSV
# Generated by config_builder.sh
#
# To modify transfers, edit rsync_sources.csv and re-run:
#   ./config_builder.sh

transfers:
EOF

    # Track line number and valid entries
    local line_num=0
    local valid_count=0
    local warning_count=0

    # Read CSV and parse (skip header) - use process substitution to avoid subshell
    while IFS= read -r line || [ -n "$line" ]; do
        ((line_num++))

        # Skip empty lines and comments
        if [[ -z "$line" ]] || [[ "$line" =~ ^[[:space:]]*$ ]] || [[ "$line" =~ ^# ]]; then
            continue
        fi

        # Parse CSV line - handle quoted fields and simple comma-separated
        # Remove any quotes and split by comma
        local source
        local destination
        
        # Use awk to properly parse CSV (handles quoted fields)
        if command -v awk &> /dev/null; then
            source=$(echo "$line" | awk -F',' '{gsub(/^[ \t]+|[ \t]+$/, "", $1); gsub(/^["\047]|["\047]$/, "", $1); print $1}')
            destination=$(echo "$line" | awk -F',' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); gsub(/^["\047]|["\047]$/, "", $2); print $2}')
        else
            # Fallback: simple comma split and trim
            source=$(echo "$line" | cut -d',' -f1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/^["'\'']//;s/["'\'']$//')
            destination=$(echo "$line" | cut -d',' -f2 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/^["'\'']//;s/["'\'']$//')
        fi

        # Validate both fields are present
        if [[ -z "$source" ]] || [[ -z "$destination" ]]; then
            print_status $YELLOW "  Warning: Line $((line_num + 1)) missing source or destination, skipping"
            ((warning_count++))
            continue
        fi

        # Check if source directory exists
        if [ ! -d "$source" ]; then
            print_status $YELLOW "  Warning: Source directory does not exist: $source"
            print_status $YELLOW "           (Line $((line_num + 1)) - will be added to config but may fail during transfer)"
            ((warning_count++))
        fi

        # Add to YAML
        echo "  - source: $source" >> "$output_file"
        echo "    destination: $destination" >> "$output_file"
        echo "" >> "$output_file"

        ((valid_count++))
    done < <(tail -n +2 "$csv_file")

    # Report results
    if [ $valid_count -eq 0 ]; then
        print_status $RED "ERROR: No valid transfers were generated"
        rm -f "$output_file"
        return 1
    fi

    print_status $GREEN "✓ Generated $valid_count transfer(s) in $output_file"
    if [ $warning_count -gt 0 ]; then
        print_status $YELLOW "  $warning_count warning(s) - see above"
    fi

    return 0
}

# Function to display preview of generated config
preview_config() {
    local config_file=$1

    print_status $CYAN ""
    print_status $CYAN "=== Preview of Generated Configuration ==="
    cat "$config_file"
    print_status $CYAN "=========================================="
    print_status $CYAN ""
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -i|--input)
                if [[ $# -lt 2 ]]; then
                    print_status $RED "ERROR: -i/--input option requires an argument"
                    usage
                fi
                CSV_FILE="$2"
                shift 2
                ;;
            -o|--output)
                if [[ $# -lt 2 ]]; then
                    print_status $RED "ERROR: -o/--output option requires an argument"
                    usage
                fi
                CONFIG_FILE="$2"
                shift 2
                ;;
            -y|--yes)
                SKIP_CONFIRM=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            *)
                print_status $RED "Unknown option: $1"
                usage
                ;;
        esac
    done
}

# Main execution
main() {
    print_status $BLUE "=== CSV to YAML Config Builder ==="
    echo ""

    # Parse arguments
    parse_arguments "$@"

    # Display what we're doing
    print_status $CYAN "Input CSV:  $CSV_FILE"
    print_status $CYAN "Output YAML: $CONFIG_FILE"
    echo ""

    # Validate CSV file
    if ! validate_csv "$CSV_FILE"; then
        exit 1
    fi

    echo ""

    # Check if output file exists and warn
    if [ -f "$CONFIG_FILE" ]; then
        if [ "$SKIP_CONFIRM" = false ]; then
            print_status $YELLOW "Warning: $CONFIG_FILE already exists and will be overwritten"
            read -p "Continue? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                print_status $YELLOW "Operation cancelled"
                exit 0
            fi
        else
            print_status $YELLOW "Warning: $CONFIG_FILE already exists and will be overwritten"
        fi
    fi

    # Generate YAML configuration
    if ! generate_yaml "$CSV_FILE" "$CONFIG_FILE"; then
        exit 1
    fi

    echo ""

    # Show preview
    preview_config "$CONFIG_FILE"

    print_status $GREEN "✓ Configuration file ready!"
    print_status $BLUE "You can now run: ./rsync_app.sh"
    echo ""
}

# Run main function
main "$@"
